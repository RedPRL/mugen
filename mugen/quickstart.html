<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>quickstart (mugen.quickstart)</title><meta charset="utf-8"/><link rel="stylesheet" href="../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.4"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="index.html">Up</a> – <a href="index.html">mugen</a> &#x00BB; quickstart</nav><header class="odoc-preamble"><h1 id="quickstart-tutorial"><a href="#quickstart-tutorial" class="anchor"></a>Quickstart Tutorial</h1><p>This tutorial is for an implementer (you!) to integrate this library into your type theory implementation as quickly as possible. We will assume you are already familiar with OCaml and dependent type theory, and are using a typical OCaml package structure.</p></header><nav class="odoc-toc"><ul><li><a href="#introduction">Introduction</a></li><li><a href="#choose-your-displacements">Choose Your Displacements</a></li><li><a href="#free-level-expressions">Free Level Expressions</a></li><li><a href="#extend-your-syntax">Extend Your Syntax</a><ul><li><a href="#change-the-datatype">Change the Datatype</a></li><li><a href="#add-converters">Add Converters</a></li><li><a href="#add-smart-constructors">Add Smart Constructors</a></li></ul></li><li><a href="#comparing-levels">Comparing Levels</a></li><li><a href="#building-levels">Building Levels</a></li><li><a href="#concluding-notes">Concluding Notes</a><ul><li><a href="#ugly-printers-for-debugging">Ugly Printers for Debugging</a></li><li><a href="#changing-the-displacement-algebra">Changing the Displacement Algebra</a></li></ul></li></ul></nav><div class="odoc-content"><h2 id="introduction"><a href="#introduction" class="anchor"></a>Introduction</h2><p>Following <a href="https://personal.cis.strath.ac.uk/conor.mcbride/Crude.pdf">Conor McBride’s crude but effective stratification</a> and <a href="https://doi.org/10.1145/3571250">our algebraic reformulation</a>, a universe level in this library is represented as a pair of a variable together with some <em>displacement</em>. For example, a universe level might be <code>x + 10</code>, meaning the variable level <code>x</code> shifted (bumped) by 10 levels. The shifting of 10 levels is the displacement. For the same variable <code>x</code>, the level <code>x + n</code> is larger than <code>x + m</code> if <code>n</code> is larger than <code>m</code>, while levels <code>x + n</code> and <code>y + m</code> are in general incomparable for different variables <code>x</code> and <code>y</code>. Substituting <code>x + n1</code> for <code>y</code> in <code>y + n2</code> results in the level <code>x + (n1 + n2)</code>.</p><p>While this scheme (with only a variable and some displacement) looks limited, we proved that it is in a sense <em>universal</em> if you allow all mathematically possible displacements beyond natural numbers. We also call the minimum algebra of displacements that would make the scheme work a <em>displacement algebra</em>. See our <a href="https://doi.org/10.1145/3571250">POPL paper</a> for more details.</p><p>This library implements several displacement algebras you could choose from, along with a uniform interface to construct and compare universe levels.</p><h2 id="choose-your-displacements"><a href="#choose-your-displacements" class="anchor"></a>Choose Your Displacements</h2><p>The first step is to choose your favorite <em>displacements</em>. We will use <a href="Mugen/Shift/Int/index.html"><code>Mugen.Shift.Int</code></a> (integers) as the starting point, and it is easy to switch to another displacement algebra later. Other displacements are under <a href="Mugen/Shift/index.html"><code>Mugen.Shift</code></a> and <a href="Mugen/ShiftWithJoin/index.html"><code>Mugen.ShiftWithJoin</code></a>.</p><h2 id="free-level-expressions"><a href="#free-level-expressions" class="anchor"></a>Free Level Expressions</h2><p><em>Free</em> level expressions are expressions freely generated by only variables and shifting operators. In contrast, we will have a different kind of level expressions embedded in your datatype holding terms or types. The free level expressions are the only ones that can be compared against each other; the embedded ones must be converted to free ones for comparison. More on this point later.</p><p>Save the following content as the file <code>ULvl.ml</code> for free level expressions, assuming that you are using integers to represent variables.</p><pre class="language-ocaml"><code>module Param =
struct
  (** Your chosen displacement algebra *)
  module Shift = Mugen.Shift.Int

  (** The representation of variables in free level expressions *)
  type var = int

  (** The equality checker for variables *)
  let equal_var : var -&gt; var -&gt; bool = Int.equal
end
include Param

(** An alias of the type of displacements *)
type shift = Shift.t

(** An alias of the type of free level expressions *)
type t = (shift, int) Mugen.Syntax.free

(** Smart constructors for free level expressions *)
include Mugen.Builder.Free.Make (Param)

(** Comparators for free level expressions *)
include Mugen.Theory.Make (Param)</code></pre><p>Take a look at <a href="Mugen/Syntax/index.html#type-free"><code>Mugen.Syntax.free</code></a> for the definition of free level expressions.</p><h2 id="extend-your-syntax"><a href="#extend-your-syntax" class="anchor"></a>Extend Your Syntax</h2><p>Now we have the free level expressions ready, you need to extend your datatype to embed levels and define the conversion functions to free ones. A typical datatype holding terms or types will have the following pattern:</p><pre class="language-ocaml"><code>type t =
  | Var of int (* maybe using De Bruijn indexes or levels *)
  (* ... more syntax follows ... *)</code></pre><p>There are three steps to add level expressions to your datatype</p><h3 id="change-the-datatype"><a href="#change-the-datatype" class="anchor"></a>Change the Datatype</h3><p>The idea is to use <a href="Mugen/Syntax/index.html#type-endo"><code>Mugen.Syntax.endo</code></a>, instead of <a href="Mugen/Syntax/index.html#type-free"><code>Mugen.Syntax.free</code></a>, so that displacements can syntactically apply to any term or type in your language (but most of them will be ill-formed terms or types). The first parameter of <a href="Mugen/Syntax/index.html#type-endo"><code>Mugen.Syntax.endo</code></a> is the type of displacements, and the second parameter is your datatype. It needs to be defined together with your datatype due to the mutual recursion; in the following example, we choose to add a new constructor, <code>ULvl</code>, to embed level expressions:</p><pre class="language-ocaml"><code>(** Use [endo] to embed levels into your datatype. *)
type ulvl = (ULvl.shift, t) Mugen.Syntax.endo

(** The datatype of terms. *)
and t =
  | Var of int
  (* ... more syntax follows ... *)
  | ULvl of ulvl</code></pre><p>You can take a look at <a href="Mugen/Syntax/index.html#type-endo"><code>Mugen.Syntax.endo</code></a> for the definition of embedded level expressions.</p><h3 id="add-converters"><a href="#add-converters" class="anchor"></a>Add Converters</h3><pre class="language-ocaml"><code>(** Conversion to free level expressions *)
let rec to_ulvl : t -&gt; ULvl.t =
  function
  | Var i -&gt; Mugen.Syntax.Var i
  | ULvl endo -&gt; endo_to_ulvl endo
  | _ -&gt; invalid_arg &quot;to_ulvl&quot;

and endo_to_ulvl : ulvl -&gt; ULvl.t =
  let module M = Mugen.Syntax in
  function
  | M.Shifted (l, s) -&gt; ULvl.shifted (to_ulvl l) s
  | M.Top -&gt; ULvl.top</code></pre><h3 id="add-smart-constructors"><a href="#add-smart-constructors" class="anchor"></a>Add Smart Constructors</h3><h2 id="comparing-levels"><a href="#comparing-levels" class="anchor"></a>Comparing Levels</h2><p>The most common tasks are to compare two embedded levels. The code is straightforward---the <code>ULvl</code> module you have created comes with comparators for free level expressions. It is sufficient to convert embedded level expressions to free ones and compare them accordingly. Copy and paste the following code snippet after the definition of your datatype:</p><pre class="language-ocaml"><code>(** Conversion to free level expressions *)
let rec to_ulvl : t -&gt; ULvl.t =
  function
  | Var i -&gt; Mugen.Syntax.Var i
  | ULvl endo -&gt; endo_to_ulvl endo
  | _ -&gt; invalid_arg &quot;to_ulvl&quot;

and endo_to_ulvl : ulvl -&gt; ULvl.t =
  let module M = Mugen.Syntax in
  function
  | M.Shifted (l, s) -&gt; ULvl.shifted (to_ulvl l) s
  | M.Top -&gt; ULvl.top</code></pre><p>Now, the comparators for embedded level expressions can be defined as followed:</p><pre class="language-ocaml"><code>let equal_ulvl l1 l2 = ULvl.equal (to_ulvl l1) (to_ulvl l2)
let leq_ulvl l1 l2 = ULvl.leq (to_ulvl l1) (to_ulvl l2)
let lt_ulvl l1 l2 = ULvl.lt (to_ulvl l1) (to_ulvl l2)</code></pre><p>You might have noticed that there is a &quot;top&quot; level---we added the top level for convenience.</p><h2 id="building-levels"><a href="#building-levels" class="anchor"></a>Building Levels</h2><p>Another common task in a real system is to parse user inputs and construct corresponding (embedded) level expressions. The recommended approach is to use smart constructors that will consolidate displacements when building level expressions. To do so, these smart constructors need to know how to check whether an expression in your datatype is a level expression. Here is the snippet to copy and paste to summon smart constructors:</p><pre class="language-ocaml"><code>(** Include smart constructors for universe levels *)
include
  Mugen.Builder.Endo.Make
    (struct
      (** Your chosen displacement algebra *)
      module Shift = ULvl.Shift

      (** The type of embedded level expressions *)
      type level = t

      (** A function to embed a level expression *)
      let level (l : ulvl) : t = ULvl l

      (** A function to check whether an expression is an embedded level expression *)
      let unlevel : t -&gt; ulvl option = function ULvl l -&gt; Some l | _ -&gt; None
    end)</code></pre><p>See Remember that you have included the smart constructors in previous steps.</p><p>The essential one</p><pre class="language-ocaml"><code>let _ = shifted l s</code></pre><p>to obtain the level <code>l</code> shifted by the displacement <code>s</code>. Constructing the displacement <code>s</code> depends on your chosen displacement algebra. If you were using integers, aliasing the stock <a href="Mugen/Shift/Int/index.html"><code>Mugen.Shift.Int</code></a> as <code>ULvl.Shift</code>), then the shifting by 10 levels can be implemented as:</p><pre class="language-ocaml"><code>let _ = shifted l (ULvl.Shift.of_int 10)</code></pre><p>For convenience, we also introduced the top level</p><pre class="language-ocaml"><code>let _ = top</code></pre><p>that will be greater than any other level. (Note that you cannot shift the distinguished top level!)</p><h2 id="concluding-notes"><a href="#concluding-notes" class="anchor"></a>Concluding Notes</h2><p>That's it! Now you have rich universe levels. Here are a few remarks:</p><h3 id="ugly-printers-for-debugging"><a href="#ugly-printers-for-debugging" class="anchor"></a>Ugly Printers for Debugging</h3><p>It is recommended to write your own pretty printer. However, if you wish to dump the universe levels, check out <a href="Mugen/Syntax/Free/index.html#val-dump"><code>Mugen.Syntax.Free.dump</code></a> for free level expressions and <a href="Mugen/Syntax/Endo/index.html#val-dump"><code>Mugen.Syntax.Endo.dump</code></a> for embedded ones.</p><h3 id="changing-the-displacement-algebra"><a href="#changing-the-displacement-algebra" class="anchor"></a>Changing the Displacement Algebra</h3><p>It is trivial to switch to another displacement algebra by aliasing <code>ULvl.Shift</code> to another module implementing the interface <a href="Mugen/Shift/module-type-S/index.html"><code>Mugen.Shift.S</code></a>. Changing the displacement algebra only affects how displacements are constructed and printed.</p></div></body></html>
